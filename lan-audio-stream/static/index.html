<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>üéµ LAN Audio Stream</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a25;
            --accent: #6366f1;
            --accent-glow: rgba(99, 102, 241, 0.4);
            --accent-hover: #818cf8;
            --text-primary: #ffffff;
            --text-secondary: #a1a1aa;
            --text-muted: #52525b;
            --success: #22c55e;
            --warning: #f59e0b;
            --error: #ef4444;
            --border: rgba(255, 255, 255, 0.1);
            
            /* Fluid responsive sizing */
            --space-xs: clamp(0.5rem, 1vw, 0.75rem);
            --space-sm: clamp(0.75rem, 2vw, 1rem);
            --space-md: clamp(1rem, 3vw, 1.5rem);
            --space-lg: clamp(1.5rem, 4vw, 2rem);
            --space-xl: clamp(2rem, 5vw, 2.5rem);
            
            /* Fluid typography */
            --font-xs: clamp(0.625rem, 1.5vw, 0.75rem);
            --font-sm: clamp(0.75rem, 2vw, 0.875rem);
            --font-md: clamp(0.875rem, 2.5vw, 1rem);
            --font-lg: clamp(1.125rem, 3vw, 1.5rem);
            --font-xl: clamp(1.25rem, 4vw, 1.75rem);
            --font-2xl: clamp(1.5rem, 5vw, 2rem);
            
            /* Component sizing */
            --btn-size: clamp(55px, 15vw, 80px);
            --logo-size: clamp(32px, 10vw, 48px);
            --bar-width: clamp(3px, 1vw, 6px);
            --visualizer-height: clamp(70px, 20vw, 120px);
            --card-padding: clamp(15px, 5vw, 40px);
            --card-radius: clamp(14px, 4vw, 24px);
        }

        html {
            font-size: 16px;
            -webkit-text-size-adjust: 100%;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            min-height: 100dvh; /* Dynamic viewport height for mobile browsers */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--space-md);
            overflow-x: hidden;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        /* Animated background */
        .bg-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
        }

        .bg-animation::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(ellipse at 20% 80%, rgba(99, 102, 241, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(139, 92, 246, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(99, 102, 241, 0.05) 0%, transparent 70%);
            animation: bgPulse 8s ease-in-out infinite;
        }

        @keyframes bgPulse {
            0%, 100% { transform: scale(1) rotate(0deg); opacity: 1; }
            50% { transform: scale(1.1) rotate(5deg); opacity: 0.8; }
        }

        /* Floating particles */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: -1;
        }

        .particle {
            position: absolute;
            width: 6px;
            height: 6px;
            background: var(--accent);
            border-radius: 50%;
            opacity: 0.3;
            animation: floatParticle 15s infinite ease-in-out;
        }

        .particle:nth-child(1) { left: 10%; animation-delay: 0s; animation-duration: 12s; }
        .particle:nth-child(2) { left: 20%; animation-delay: 2s; animation-duration: 14s; }
        .particle:nth-child(3) { left: 30%; animation-delay: 4s; animation-duration: 16s; }
        .particle:nth-child(4) { left: 40%; animation-delay: 1s; animation-duration: 13s; }
        .particle:nth-child(5) { left: 50%; animation-delay: 3s; animation-duration: 15s; }
        .particle:nth-child(6) { left: 60%; animation-delay: 5s; animation-duration: 11s; }
        .particle:nth-child(7) { left: 70%; animation-delay: 2s; animation-duration: 17s; }
        .particle:nth-child(8) { left: 80%; animation-delay: 4s; animation-duration: 12s; }
        .particle:nth-child(9) { left: 90%; animation-delay: 1s; animation-duration: 14s; }
        .particle:nth-child(10) { left: 95%; animation-delay: 3s; animation-duration: 16s; }

        @keyframes floatParticle {
            0%, 100% {
                transform: translateY(100vh) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 0.5;
                transform: translateY(90vh) scale(1);
            }
            90% {
                opacity: 0.3;
                transform: translateY(10vh) scale(0.8);
            }
            100% {
                opacity: 0;
                transform: translateY(0vh) scale(0);
            }
        }

        /* Page load animation */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes scaleIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes glowPulse {
            0%, 100% {
                box-shadow: 0 0 20px var(--accent-glow), 0 0 40px rgba(99, 102, 241, 0.2);
            }
            50% {
                box-shadow: 0 0 30px var(--accent-glow), 0 0 60px rgba(99, 102, 241, 0.3);
            }
        }

        @keyframes shimmer {
            0% {
                background-position: -200% center;
            }
            100% {
                background-position: 200% center;
            }
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        /* Main container */
        .container {
            width: 100%;
            max-width: min(420px, 100% - var(--space-md) * 2);
            perspective: 1000px;
            animation: fadeInUp 0.8s ease-out;
            container-type: inline-size;
            container-name: main-container;
        }

        /* Player card */
        .player-card {
            background: linear-gradient(145deg, var(--bg-secondary) 0%, var(--bg-primary) 100%);
            border: 1px solid var(--border);
            border-radius: var(--card-radius);
            padding: var(--card-padding);
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.5),
                0 0 0 1px rgba(255, 255, 255, 0.05) inset;
            backdrop-filter: blur(20px);
            transform-style: preserve-3d;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            animation: scaleIn 0.6s ease-out 0.2s both;
            width: 100%;
        }

        .player-card:hover {
            transform: translateY(-8px) rotateX(2deg);
            box-shadow: 
                0 35px 60px -15px rgba(0, 0, 0, 0.6),
                0 0 0 1px rgba(255, 255, 255, 0.08) inset,
                0 0 40px rgba(99, 102, 241, 0.15);
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: var(--space-lg);
        }

        .logo {
            font-size: var(--logo-size);
            margin-bottom: var(--space-sm);
            display: inline-block;
            animation: float 3s ease-in-out infinite, scaleIn 0.5s ease-out 0.4s both;
            filter: drop-shadow(0 0 20px var(--accent-glow));
            transition: transform 0.3s ease, filter 0.3s ease;
        }

        .logo:hover {
            transform: scale(1.2) rotate(10deg);
            filter: drop-shadow(0 0 30px var(--accent-glow));
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .title {
            font-size: var(--font-2xl);
            font-weight: 700;
            background: linear-gradient(135deg, var(--text-primary) 0%, var(--accent) 50%, var(--text-primary) 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: var(--space-xs);
            animation: fadeInUp 0.5s ease-out 0.5s both, shimmer 3s linear infinite;
            line-height: 1.2;
        }

        .subtitle {
            font-size: var(--font-sm);
            color: var(--text-secondary);
            font-weight: 400;
            animation: fadeInUp 0.5s ease-out 0.6s both;
            transition: color 0.3s ease;
            line-height: 1.4;
        }

        .subtitle:hover {
            color: var(--text-primary);
        }

        /* Visualizer */
        .visualizer-container {
            position: relative;
            height: var(--visualizer-height);
            margin-bottom: var(--space-lg);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: clamp(2px, 0.8vw, 4px);
            overflow: hidden;
            border-radius: clamp(10px, 3vw, 16px);
            background: var(--bg-tertiary);
            padding: var(--space-md);
            animation: fadeInUp 0.5s ease-out 0.7s both;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .visualizer-container:hover {
            border-color: var(--accent-glow);
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.1) inset;
        }

        .visualizer-bar {
            width: var(--bar-width);
            background: linear-gradient(to top, var(--accent), var(--accent-hover), #a78bfa);
            border-radius: calc(var(--bar-width) / 2);
            transition: height 0.08s ease-out, transform 0.2s ease;
            box-shadow: 0 0 10px var(--accent-glow);
            flex-shrink: 0;
        }

        .visualizer-bar:hover {
            transform: scaleY(1.1);
        }

        .visualizer-bar.inactive {
            height: 4px !important;
            opacity: 0.3;
            animation: barIdle 2s ease-in-out infinite;
        }

        .visualizer-bar.inactive:nth-child(odd) {
            animation-delay: 0.5s;
        }

        @keyframes barIdle {
            0%, 100% { transform: scaleY(1); }
            50% { transform: scaleY(1.5); }
        }

        /* Status indicator */
        .status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-sm);
            margin-bottom: var(--space-lg);
            padding: var(--space-sm) var(--space-md);
            background: var(--bg-tertiary);
            border-radius: clamp(8px, 2vw, 12px);
            font-size: var(--font-sm);
            font-weight: 500;
            animation: fadeInUp 0.5s ease-out 0.8s both;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .status:hover {
            background: rgba(26, 26, 37, 0.8);
            border-color: var(--border);
            transform: scale(1.02);
        }

        .status-dot {
            width: clamp(8px, 2vw, 10px);
            height: clamp(8px, 2vw, 10px);
            border-radius: 50%;
            background: var(--text-muted);
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .status-dot.connected {
            background: var(--success);
            box-shadow: 0 0 12px var(--success);
            animation: pulse 2s ease-in-out infinite;
        }

        .status-dot.connecting {
            background: var(--warning);
            animation: blink 1s ease-in-out infinite;
        }

        .status-dot.error {
            background: var(--error);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Play button */
        .play-button {
            width: var(--btn-size);
            height: var(--btn-size);
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, var(--accent) 0%, #8b5cf6 100%);
            color: white;
            font-size: clamp(20px, 6vw, 32px);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto var(--space-lg);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 
                0 10px 40px var(--accent-glow),
                0 0 0 0 var(--accent-glow);
            position: relative;
            overflow: hidden;
            animation: scaleIn 0.5s ease-out 0.9s both;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .play-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }

        .play-button:hover::before {
            left: 100%;
        }

        .play-button:hover {
            transform: scale(1.1);
            box-shadow: 
                0 15px 50px var(--accent-glow),
                0 0 0 8px rgba(99, 102, 241, 0.2);
        }

        .play-button:active {
            transform: scale(0.95);
        }

        .play-button.playing {
            animation: playingPulse 2s ease-in-out infinite;
        }

        @keyframes playingPulse {
            0%, 100% { box-shadow: 0 10px 40px var(--accent-glow), 0 0 0 0 var(--accent-glow); }
            50% { box-shadow: 0 10px 40px var(--accent-glow), 0 0 0 15px rgba(99, 102, 241, 0.1); }
        }

        .play-icon, .pause-icon {
            display: none;
        }

        .play-button:not(.playing) .play-icon {
            display: block;
            margin-left: 4px;
        }

        .play-button.playing .pause-icon {
            display: flex;
            gap: 6px;
        }

        .pause-icon span {
            width: clamp(4px, 1vw, 6px);
            height: clamp(16px, 5vw, 24px);
            background: white;
            border-radius: 2px;
        }

        /* Volume control */
        .volume-control {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            padding: 0 var(--space-sm);
            margin-bottom: var(--space-md);
            animation: fadeInUp 0.5s ease-out 1s both;
        }

        .volume-icon {
            font-size: clamp(16px, 4vw, 20px);
            color: var(--text-secondary);
            min-width: clamp(20px, 5vw, 24px);
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            flex-shrink: 0;
        }

        .volume-icon:hover {
            transform: scale(1.2);
            filter: drop-shadow(0 0 10px var(--accent-glow));
        }

        .volume-slider {
            flex: 1;
            height: clamp(4px, 1.5vw, 6px);
            -webkit-appearance: none;
            appearance: none;
            background: var(--bg-tertiary);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
            min-width: 0;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: clamp(16px, 4vw, 20px);
            height: clamp(16px, 4vw, 20px);
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--accent-glow);
            transition: transform 0.2s ease;
        }

        .volume-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .volume-slider::-moz-range-thumb {
            width: clamp(16px, 4vw, 20px);
            height: clamp(16px, 4vw, 20px);
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px var(--accent-glow);
        }

        .volume-value {
            font-size: var(--font-sm);
            color: var(--text-secondary);
            min-width: clamp(30px, 8vw, 40px);
            text-align: right;
            font-weight: 500;
            flex-shrink: 0;
        }

        /* Stats */
        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--space-sm);
            padding-top: var(--space-md);
            border-top: 1px solid var(--border);
            animation: fadeInUp 0.5s ease-out 1.1s both;
        }

        .stat {
            text-align: center;
            padding: var(--space-sm);
            border-radius: clamp(6px, 2vw, 10px);
            transition: all 0.3s ease;
            cursor: default;
            min-width: 0;
        }

        .stat:hover {
            background: var(--bg-tertiary);
            transform: translateY(-3px);
        }

        .stat-value {
            font-size: var(--font-lg);
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--space-xs);
            transition: all 0.3s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .stat:hover .stat-value {
            color: var(--accent);
            transform: scale(1.1);
        }

        .stat-label {
            font-size: var(--font-xs);
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: color 0.3s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .stat:hover .stat-label {
            color: var(--text-secondary);
        }

        /* Footer */
        .footer {
            margin-top: var(--space-lg);
            text-align: center;
            color: var(--text-muted);
            font-size: var(--font-xs);
            animation: fadeInUp 0.5s ease-out 1.2s both;
            padding: 0 var(--space-sm);
        }

        .footer a {
            color: var(--accent);
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .footer a:hover {
            color: var(--accent-hover);
            text-shadow: 0 0 10px var(--accent-glow);
        }

        .footer-text {
            margin-bottom: var(--space-xs);
            transition: color 0.3s ease;
            line-height: 1.5;
        }

        .footer-text:hover {
            color: var(--text-secondary);
        }

        /* Copyright */
        .copyright {
            margin-top: var(--space-sm);
            padding-top: var(--space-sm);
            border-top: 1px solid var(--border);
            font-size: var(--font-xs);
            color: var(--text-muted);
            animation: fadeInUp 0.5s ease-out 1.3s both;
            transition: all 0.3s ease;
        }

        .copyright:hover {
            color: var(--text-secondary);
        }

        .copyright .dev-name {
            color: var(--accent);
            font-weight: 600;
            background: linear-gradient(135deg, var(--accent) 0%, #a78bfa 50%, var(--accent) 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 3s linear infinite;
            transition: all 0.3s ease;
        }

        .copyright:hover .dev-name {
            filter: brightness(1.2);
        }

        .copyright .heart {
            color: #ef4444;
            display: inline-block;
            animation: heartbeat 1.5s ease-in-out infinite;
        }

        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            25% { transform: scale(1.2); }
            50% { transform: scale(1); }
            75% { transform: scale(1.2); }
        }

        /* Responsive - Large tablets and small desktops */
        @media (max-width: 1024px) {
            :root {
                --card-padding: clamp(15px, 4vw, 35px);
            }
        }

        /* Responsive - Tablets */
        @media (max-width: 768px) {
            body {
                justify-content: flex-start;
                padding-top: max(20px, env(safe-area-inset-top));
                padding-bottom: max(20px, env(safe-area-inset-bottom));
            }

            :root {
                --visualizer-height: clamp(70px, 18vw, 100px);
            }
        }

        /* Responsive - Mobile phones */
        @media (max-width: 480px) {
            body {
                padding-left: max(10px, env(safe-area-inset-left));
                padding-right: max(10px, env(safe-area-inset-right));
            }

            :root {
                --btn-size: clamp(55px, 16vw, 70px);
                --logo-size: clamp(30px, 10vw, 40px);
                --bar-width: clamp(3px, 1.2vw, 5px);
                --visualizer-height: clamp(70px, 22vw, 90px);
            }

            .player-card:hover {
                transform: none;
            }

            /* Reduce particles on mobile for performance */
            .particle:nth-child(n+7) {
                display: none;
            }

            .toast {
                max-width: calc(100% - 20px);
                left: 10px;
                right: 10px;
                transform: translateX(0) translateY(100px);
            }

            .toast.show {
                transform: translateX(0) translateY(0);
            }
        }

        /* Responsive - Very small phones */
        @media (max-width: 360px) {
            :root {
                --btn-size: clamp(50px, 18vw, 60px);
                --logo-size: clamp(28px, 10vw, 36px);
                --bar-width: clamp(2px, 1vw, 4px);
                --visualizer-height: clamp(60px, 20vw, 80px);
                --card-padding: clamp(12px, 4vw, 20px);
            }
        }

        /* Container queries for more precise control */
        @container main-container (max-width: 350px) {
            .stats {
                grid-template-columns: repeat(3, 1fr);
                gap: 4px;
            }

            .stat {
                padding: 6px 2px;
            }

            .volume-control {
                gap: 8px;
            }
        }

        @container main-container (max-width: 280px) {
            .header {
                margin-bottom: 12px;
            }

            .visualizer-container {
                margin-bottom: 12px;
            }

            .status {
                margin-bottom: 12px;
            }

            .play-button {
                margin-bottom: 12px;
            }

            .stats {
                padding-top: 12px;
            }
        }

        /* Responsive - Landscape mode on phones */
        @media (max-height: 500px) and (orientation: landscape) {
            body {
                padding: 10px 20px;
                justify-content: center;
            }

            .container {
                max-width: min(500px, 90vw);
            }

            .player-card {
                display: grid;
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto auto auto;
                gap: 12px;
            }

            .header {
                grid-column: 1 / -1;
                margin-bottom: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 12px;
                flex-wrap: wrap;
            }

            .header > div:last-child {
                display: flex;
                flex-direction: column;
            }

            .logo {
                margin-bottom: 0;
            }

            .visualizer-container {
                grid-column: 1;
                height: clamp(60px, 15vh, 80px);
                margin-bottom: 0;
            }

            .status {
                display: none;
            }

            .play-button {
                margin: 0;
                grid-column: 2;
                grid-row: 2;
                justify-self: center;
                align-self: center;
            }

            .volume-control {
                grid-column: 2;
                margin-bottom: 0;
            }

            .stats {
                grid-column: 1 / -1;
            }

            .footer {
                margin-top: 10px;
            }

            .copyright {
                margin-top: 6px;
                padding-top: 6px;
            }

            /* Hide most particles in landscape for performance */
            .particle:nth-child(n+4) {
                display: none;
            }
        }

        /* Ultra-wide landscape */
        @media (min-aspect-ratio: 2/1) and (max-height: 600px) {
            .container {
                max-width: min(450px, 50vw);
            }
        }

        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .player-card:hover {
                transform: none;
                box-shadow: 
                    0 25px 50px -12px rgba(0, 0, 0, 0.5),
                    0 0 0 1px rgba(255, 255, 255, 0.05) inset;
            }

            .play-button:hover {
                transform: none;
            }

            .play-button:active {
                transform: scale(0.95);
            }

            .stat:hover {
                background: transparent;
                transform: none;
            }

            .stat:hover .stat-value {
                color: var(--text-primary);
                transform: none;
            }

            .volume-icon:hover {
                transform: none;
            }

            .logo:hover {
                transform: none;
            }

            /* Larger touch targets for better usability */
            .play-button {
                min-width: 54px;
                min-height: 54px;
            }

            .volume-slider {
                height: 8px;
            }

            .volume-slider::-webkit-slider-thumb {
                width: 24px;
                height: 24px;
            }

            .volume-slider::-moz-range-thumb {
                width: 24px;
                height: 24px;
            }
        }

        /* Fine pointer (mouse) with touch support */
        @media (pointer: fine) and (any-pointer: coarse) {
            .volume-slider::-webkit-slider-thumb {
                width: 20px;
                height: 20px;
            }
        }

        /* Prefers reduced motion */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }

            .particle {
                display: none;
            }

            .bg-animation::before {
                animation: none;
            }
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            :root {
                --border: rgba(255, 255, 255, 0.4);
                --text-secondary: #c4c4c4;
            }

            .player-card {
                border-width: 2px;
            }

            .status {
                border: 2px solid var(--border);
            }

            .play-button {
                border: 2px solid white;
            }
        }

        /* Dark mode preference (already dark, but ensure consistency) */
        @media (prefers-color-scheme: dark) {
            :root {
                color-scheme: dark;
            }
        }

        /* Print styles */
        @media print {
            .bg-animation,
            .particles,
            .visualizer-container,
            .play-button,
            .volume-control {
                display: none;
            }

            body {
                background: white;
                color: black;
            }

            .player-card {
                box-shadow: none;
                border: 1px solid #ccc;
            }
        }

        /* Loading animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--text-muted);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Toast notifications */
        .toast {
            position: fixed;
            bottom: max(20px, env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            padding: var(--space-sm) var(--space-md);
            border-radius: clamp(8px, 2vw, 12px);
            font-size: var(--font-sm);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
            max-width: calc(100vw - var(--space-md) * 2);
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .toast.success {
            border-color: var(--success);
        }

        .toast.error {
            border-color: var(--error);
        }
    </style>
</head>
<body>
    <div class="bg-animation"></div>
    
    <!-- Floating particles -->
    <div class="particles">
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
    </div>
    
    <div class="container">
        <div class="player-card">
            <div class="header">
                <div class="logo">üéµ</div>
                <h1 class="title">LAN Audio Stream</h1>
                <p class="subtitle">Listen to your PC audio anywhere</p>
            </div>

            <div class="visualizer-container" id="visualizer">
                <!-- Bars will be generated by JS -->
            </div>

            <div class="status">
                <span class="status-dot" id="statusDot"></span>
                <span id="statusText">Click play to connect</span>
            </div>

            <button class="play-button" id="playButton" onclick="togglePlay()">
                <span class="play-icon">‚ñ∂</span>
                <span class="pause-icon">
                    <span></span>
                    <span></span>
                </span>
            </button>

            <div class="volume-control">
                <span class="volume-icon" id="volumeIcon">üîä</span>
                <input type="range" class="volume-slider" id="volumeSlider" 
                       min="0" max="100" value="80" oninput="setVolume(this.value)">
                <span class="volume-value" id="volumeValue">80%</span>
            </div>

            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="latency">--</div>
                    <div class="stat-label">Latency</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="bitrate">48kHz</div>
                    <div class="stat-label">Sample Rate</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="buffered">0</div>
                    <div class="stat-label">Buffered</div>
                </div>
            </div>
        </div>

        <div class="footer">
            <p class="footer-text">Stream your PC audio to any device on your network</p>
            <div class="copyright">
                Made with <span class="heart">‚ù§</span> by <span class="dev-name">Ayaz</span>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        // Configuration - Responsive bar count based on screen width
        function getNumBars() {
            const width = window.innerWidth;
            if (width <= 320) return 16;
            if (width <= 480) return 24;
            if (width <= 768) return 28;
            return 32;
        }
        
        let NUM_BARS = getNumBars();
        const RECONNECT_DELAY = 2000;
        const PING_INTERVAL = 5000;
        
        // LOW LATENCY AUDIO SETTINGS (for better sync)
        const MAX_QUEUE_SIZE = 15;       // Buffer queue size
        const MIN_BUFFER_SIZE = 4;       // Minimum buffers before starting playback
        const TARGET_BUFFER_SIZE = 6;    // Target buffer count
        const TARGET_LATENCY_MS = 80;    // Low latency for sync (~80ms delay)
        const SCHEDULE_AHEAD_TIME = 0.04; // Schedule audio ahead (40ms)

        // State
        let audioContext = null;
        let gainNode = null;
        let ws = null;
        let isPlaying = false;
        let isConnecting = false;
        let sampleRate = 48000;  // High quality 48kHz
        let channels = 2;        // Stereo
        let chunkSize = 4096;
        let audioQueue = [];
        let isProcessing = false;
        let reconnectTimeout = null;
        let pingInterval = null;
        let lastPingTime = 0;
        let analyser = null;
        let animationId = null;
        let scriptNode = null;
        let nextPlayTime = 0;
        let playbackStarted = false;
        let bufferUnderrunCount = 0;
        let lastBufferCheck = 0;
        let scheduledBuffers = [];  // Track scheduled audio sources
        let smoothingFactor = 0.98; // For smooth transitions

        // DOM Elements
        const visualizer = document.getElementById('visualizer');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const playButton = document.getElementById('playButton');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValue = document.getElementById('volumeValue');
        const volumeIcon = document.getElementById('volumeIcon');
        const latencyDisplay = document.getElementById('latency');
        const bufferedDisplay = document.getElementById('buffered');
        const bitrateDisplay = document.getElementById('bitrate');

        // Initialize visualizer bars
        function initVisualizer() {
            visualizer.innerHTML = '';
            for (let i = 0; i < NUM_BARS; i++) {
                const bar = document.createElement('div');
                bar.className = 'visualizer-bar inactive';
                bar.style.height = '4px';
                visualizer.appendChild(bar);
            }
        }

        // Update visualizer with audio data
        function updateVisualizer() {
            if (!analyser || !isPlaying) {
                const bars = visualizer.querySelectorAll('.visualizer-bar');
                bars.forEach(bar => {
                    bar.classList.add('inactive');
                    bar.style.height = '4px';
                });
                return;
            }

            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);

            const bars = visualizer.querySelectorAll('.visualizer-bar');
            const step = Math.floor(dataArray.length / NUM_BARS);

            bars.forEach((bar, i) => {
                const value = dataArray[i * step] || 0;
                const height = Math.max(4, (value / 255) * 80);
                bar.style.height = `${height}px`;
                bar.classList.remove('inactive');
            });

            animationId = requestAnimationFrame(updateVisualizer);
        }

        // Initialize Web Audio API
        async function initAudio() {
            if (audioContext) return;

            // Create AudioContext for high-quality audio playback
            audioContext = new (window.AudioContext || window.webkitAudioContext)({
                latencyHint: 'playback',
                sampleRate: 48000  // CD-quality sample rate
            });

            console.log('AudioContext created, sample rate:', audioContext.sampleRate, 'base latency:', audioContext.baseLatency);

            // Create a subtle dynamics compressor for consistent levels without squashing dynamics
            const compressor = audioContext.createDynamicsCompressor();
            compressor.threshold.value = -12;  // Higher threshold = less compression
            compressor.knee.value = 20;        // Softer knee for transparent compression
            compressor.ratio.value = 4;        // Lower ratio preserves dynamics
            compressor.attack.value = 0.01;    // Slower attack preserves transients
            compressor.release.value = 0.2;    // Natural release

            // High-quality gain node
            gainNode = audioContext.createGain();
            gainNode.gain.value = volumeSlider.value / 100;

            // Analyser for visualization (doesn't affect audio quality)
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 512;  // Higher resolution
            analyser.smoothingTimeConstant = 0.8;

            // High-quality audio chain: source -> gain -> compressor -> analyser -> destination
            // No lowpass filter to preserve full frequency range
            gainNode.connect(compressor);
            compressor.connect(analyser);
            analyser.connect(audioContext.destination);

            // Resume audio context (required for autoplay policy)
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }

            console.log('AudioContext state:', audioContext.state, 'High-quality mode enabled');
            nextPlayTime = audioContext.currentTime + SCHEDULE_AHEAD_TIME;
        }

        // Connect to WebSocket server
        function connect() {
            if (ws && ws.readyState === WebSocket.OPEN) return;

            isConnecting = true;
            updateStatus('connecting', 'Connecting...');

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;

            ws = new WebSocket(wsUrl);
            ws.binaryType = 'arraybuffer';

            ws.onopen = () => {
                isConnecting = false;
                updateStatus('connected', 'Connected');
                showToast('Connected to audio stream', 'success');
                startPing();
                console.log('WebSocket connected');
            };

            ws.onmessage = async (event) => {
                if (typeof event.data === 'string') {
                    const msg = JSON.parse(event.data);
                    console.log('Received config:', msg);
                    if (msg.type === 'config') {
                        sampleRate = msg.sampleRate;
                        channels = msg.channels;
                        chunkSize = msg.chunkSize;
                        bitrateDisplay.textContent = `${sampleRate / 1000}kHz`;
                        console.log(`Config: ${sampleRate}Hz, ${channels} channels`);
                    } else if (msg.type === 'pong') {
                        const latency = Date.now() - lastPingTime;
                        latencyDisplay.textContent = `${latency}ms`;
                    }
                } else {
                    // Audio data received - add to queue
                    audioQueue.push(event.data);
                    
                    // Gentle queue management - only trim when very full
                    if (audioQueue.length > MAX_QUEUE_SIZE) {
                        // Keep more buffers for smoother playback
                        const dropCount = audioQueue.length - TARGET_BUFFER_SIZE - 2;
                        if (dropCount > 0) {
                            audioQueue.splice(0, dropCount);
                            // Smoothly adjust playback time instead of hard reset
                            if (audioContext) {
                                const adjustment = dropCount * (chunkSize / sampleRate / channels) * 0.5;
                                nextPlayTime = Math.max(audioContext.currentTime + 0.05, nextPlayTime - adjustment);
                            }
                        }
                    }
                    
                    bufferedDisplay.textContent = audioQueue.length;
                    
                    // Start playback after sufficient pre-buffer
                    if (!playbackStarted && audioQueue.length >= MIN_BUFFER_SIZE) {
                        playbackStarted = true;
                        // Start with comfortable buffer for smooth playback
                        nextPlayTime = audioContext.currentTime + (TARGET_LATENCY_MS / 1000);
                        console.log('Starting playback with buffer:', audioQueue.length);
                    }
                    
                    if (playbackStarted && !isProcessing) {
                        processAudioQueue();
                    }
                }
            };

            ws.onclose = () => {
                isConnecting = false;
                stopPing();
                
                if (isPlaying) {
                    updateStatus('error', 'Disconnected - Reconnecting...');
                    scheduleReconnect();
                } else {
                    updateStatus('', 'Click play to connect');
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                isConnecting = false;
                updateStatus('error', 'Connection error');
            };
        }

        // Store the last sample of previous buffer to blend with next buffer
        let lastSamples = null;
        
        // Blend the start of current buffer with last samples from previous buffer
        function blendBufferStart(buffer, prevSamples) {
            if (!prevSamples) return;
            
            const blendLength = 4;  // Very short blend to prevent clicks
            for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
                const data = buffer.getChannelData(channel);
                const prevSample = prevSamples[channel] || 0;
                
                // Only blend if there's a significant discontinuity
                const discontinuity = Math.abs(data[0] - prevSample);
                if (discontinuity > 0.01) {  // Only fix actual clicks
                    for (let i = 0; i < blendLength && i < data.length; i++) {
                        const t = (i + 1) / (blendLength + 1);
                        data[i] = prevSample * (1 - t) + data[i] * t;
                    }
                }
            }
        }
        
        // Store the last sample of this buffer for next blend
        function storeLastSamples(buffer) {
            const samples = [];
            for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
                const data = buffer.getChannelData(channel);
                samples[channel] = data[data.length - 1];
            }
            return samples;
        }

        // High-quality PCM to Float32 conversion with dithering
        function convertPCMToFloat32(int16Array) {
            const float32Array = new Float32Array(int16Array.length);
            const scale = 1.0 / 32768.0;
            
            for (let i = 0; i < int16Array.length; i++) {
                // Direct conversion without any processing to preserve quality
                float32Array[i] = int16Array[i] * scale;
            }
            
            return float32Array;
        }

        // Process audio queue - optimized for HIGH QUALITY gapless playback
        async function processAudioQueue() {
            if (isProcessing || audioQueue.length === 0 || !audioContext) return;
            isProcessing = true;

            const currentTime = audioContext.currentTime;
            
            // Clean up old scheduled buffers
            scheduledBuffers = scheduledBuffers.filter(item => item.endTime > currentTime);

            // Process buffers - schedule multiple ahead for gapless high-quality playback
            const buffersToProcess = Math.min(audioQueue.length, 3);
            
            for (let b = 0; b < buffersToProcess; b++) {
                const data = audioQueue.shift();
                bufferedDisplay.textContent = audioQueue.length;

                try {
                    // High-quality PCM to Float32 conversion
                    const int16Array = new Int16Array(data);
                    const float32Array = convertPCMToFloat32(int16Array);

                    // Create audio buffer at server's native sample rate (preserves quality)
                    const numFrames = float32Array.length / channels;
                    const audioBuffer = audioContext.createBuffer(channels, numFrames, sampleRate);

                    // Deinterleave channels with direct copy (no processing)
                    for (let channel = 0; channel < channels; channel++) {
                        const channelData = audioBuffer.getChannelData(channel);
                        for (let i = 0; i < numFrames; i++) {
                            channelData[i] = float32Array[i * channels + channel];
                        }
                    }

                    // Blend with previous buffer to prevent clicks at boundaries
                    blendBufferStart(audioBuffer, lastSamples);
                    lastSamples = storeLastSamples(audioBuffer);

                    // Create high-quality audio source
                    const source = audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(gainNode);

                    const bufferDuration = audioBuffer.duration;
                    const now = audioContext.currentTime;
                    const targetLatency = TARGET_LATENCY_MS / 1000;
                    
                    // Precise timing for low-latency gapless playback
                    if (nextPlayTime < now) {
                        // Buffer underrun - recover quickly
                        bufferUnderrunCount++;
                        lastSamples = null;  // Reset to prevent click
                        
                        if (bufferUnderrunCount > 5) {
                            // Multiple underruns - brief pause to refill
                            nextPlayTime = now + targetLatency;
                            bufferUnderrunCount = 0;
                        } else {
                            // Quick recovery - minimal gap
                            nextPlayTime = now + 0.005;  // 5ms
                        }
                    } else if (nextPlayTime > now + targetLatency * 1.5) {
                        // Too much latency building up - sync back
                        nextPlayTime = now + targetLatency * 0.5;
                    }
                    
                    // Schedule the buffer for gapless playback
                    source.start(nextPlayTime);
                    
                    // Track scheduled buffer for cleanup
                    const endTime = nextPlayTime + bufferDuration;
                    scheduledBuffers.push({ source, endTime });
                    
                    // Exact timing for seamless gapless playback (no overlap to preserve quality)
                    nextPlayTime += bufferDuration;

                    // Reset underrun counter when buffer is healthy
                    if (audioQueue.length >= TARGET_BUFFER_SIZE) {
                        bufferUnderrunCount = 0;
                    }

                } catch (error) {
                    console.error('Error processing audio:', error);
                }
            }

            isProcessing = false;
            
            // Schedule next processing cycle with consistent timing
            if (audioQueue.length > 0 && playbackStarted) {
                // Use setTimeout for more consistent timing than requestAnimationFrame
                setTimeout(() => processAudioQueue(), 10);  // 10ms interval
            }
        }

        // Update status display
        function updateStatus(state, text) {
            statusDot.className = 'status-dot ' + state;
            statusText.textContent = text;
        }

        // Toggle play/pause
        async function togglePlay() {
            if (isPlaying) {
                stop();
            } else {
                await play();
            }
        }

        // Start playing
        async function play() {
            try {
                await initAudio();
                connect();
                isPlaying = true;
                playButton.classList.add('playing');
                updateVisualizer();
            } catch (error) {
                console.error('Error starting playback:', error);
                showToast('Error starting playback', 'error');
            }
        }

        // Stop playing
        function stop() {
            isPlaying = false;
            playbackStarted = false;
            playButton.classList.remove('playing');
            
            if (ws) {
                ws.close();
                ws = null;
            }

            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }

            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            // Stop all scheduled audio sources
            scheduledBuffers.forEach(item => {
                try {
                    item.source.stop();
                } catch (e) {
                    // Ignore errors if already stopped
                }
            });
            scheduledBuffers = [];
            
            audioQueue = [];
            bufferUnderrunCount = 0;
            bufferedDisplay.textContent = '0';
            updateStatus('', 'Click play to connect');

            const bars = visualizer.querySelectorAll('.visualizer-bar');
            bars.forEach(bar => {
                bar.classList.add('inactive');
                bar.style.height = '4px';
            });
        }

        // Set volume with smooth ramping to avoid clicks
        function setVolume(value) {
            const volume = value / 100;
            if (gainNode && audioContext) {
                // Use exponential ramp for smooth volume change
                const now = audioContext.currentTime;
                gainNode.gain.cancelScheduledValues(now);
                gainNode.gain.setValueAtTime(gainNode.gain.value, now);
                gainNode.gain.linearRampToValueAtTime(volume, now + 0.05);
            } else if (gainNode) {
                gainNode.gain.value = volume;
            }
            volumeValue.textContent = `${value}%`;
            
            if (value == 0) {
                volumeIcon.textContent = 'üîá';
            } else if (value < 50) {
                volumeIcon.textContent = 'üîâ';
            } else {
                volumeIcon.textContent = 'üîä';
            }
        }

        // Schedule reconnect
        function scheduleReconnect() {
            if (reconnectTimeout) return;
            
            reconnectTimeout = setTimeout(() => {
                reconnectTimeout = null;
                if (isPlaying) {
                    connect();
                }
            }, RECONNECT_DELAY);
        }

        // Ping for latency measurement
        function startPing() {
            pingInterval = setInterval(() => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    lastPingTime = Date.now();
                    ws.send(JSON.stringify({ type: 'ping' }));
                }
            }, PING_INTERVAL);
        }

        function stopPing() {
            if (pingInterval) {
                clearInterval(pingInterval);
                pingInterval = null;
            }
        }

        // Show toast notification
        function showToast(message, type = '') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast ' + type;
            
            setTimeout(() => toast.classList.add('show'), 10);
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            initVisualizer();
            setVolume(volumeSlider.value);
        });

        // Handle window resize - reinitialize visualizer with appropriate bar count
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const newNumBars = getNumBars();
                if (newNumBars !== NUM_BARS) {
                    NUM_BARS = newNumBars;
                    initVisualizer();
                    if (isPlaying) {
                        updateVisualizer();
                    }
                }
            }, 250);
        });

        // Handle orientation change
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                NUM_BARS = getNumBars();
                initVisualizer();
                if (isPlaying) {
                    updateVisualizer();
                }
            }, 100);
        });

        // Handle visibility change (pause when tab is hidden to save resources)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            } else if (!document.hidden && isPlaying) {
                updateVisualizer();
            }
        });
    </script>
</body>
</html>
